<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner Pro - Diagn√≥stico</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    
    <style>
        /* RESET Y B√ÅSICOS */
        * { box-sizing: border-box; touch-action: none; /* Bloquea zoom/scroll nativo */ }
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; height: 100vh; width: 100vw; }
        
        /* CAPA DE C√ÅMARA */
        #view-camera { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; display: flex; justify-content: center; }
        canvas { width: 100%; height: 100%; object-fit: cover; }
        
        /* LOG DE ESTADO (Para saber qu√© falla) */
        #status-log {
            position: absolute; top: 10px; left: 10px; right: 10px;
            background: rgba(0,0,0,0.8); color: #00ff00;
            padding: 10px; font-family: monospace; font-size: 12px;
            z-index: 999; pointer-events: none; border-radius: 4px;
            white-space: pre-wrap;
        }

        /* BOT√ìN DISPARADOR */
        #btn-capture {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 70px; height: 70px; background: #fff; border-radius: 50%;
            border: 4px solid #ccc; z-index: 10; cursor: pointer;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #btn-capture:active { background: #ddd; transform: translateX(-50%) scale(0.95); }

        /* CAPA EDITOR (Oculta al inicio) */
        #view-editor {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; flex-direction: column;
        }
        
        /* Contenedor de la imagen a editar */
        .editor-workspace {
            flex: 1; width: 100%; position: relative; background: #000; overflow: hidden;
        }
        
        /* Barra de botones */
        .toolbar {
            height: 60px; background: #222; display: flex; justify-content: space-around; align-items: center;
        }
        .toolbar button {
            padding: 10px 20px; border-radius: 5px; border: none; font-weight: bold; color: white; font-size: 16px;
        }
        .btn-cancel { background: #d32f2f; }
        .btn-ok { background: #388e3c; }
        .btn-rot { background: #1976d2; }

        /* CAPA RESULTADO */
        #view-result {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 300; flex-direction: column; align-items: center; justify-content: center;
        }
        #final-img { max-width: 90%; max-height: 80%; border: 2px solid white; margin-bottom: 20px; }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="status-log">Iniciando... Espera.</div>

    <div id="view-camera">
        <video id="video" playsinline muted></video>
        <canvas id="canvas-out"></canvas>
        <div id="btn-capture"></div>
    </div>

    <div id="view-editor">
        <div class="editor-workspace">
            <img id="image-to-edit" style="max-width: 100%; display:none;"> 
        </div>
        <div class="toolbar">
            <button class="btn-cancel" onclick="app.reset()">‚ùå</button>
            <button class="btn-rot" onclick="app.rotate(-90)">‚Ü∫</button>
            <button class="btn-rot" onclick="app.rotate(90)">‚Üª</button>
            <button class="btn-ok" onclick="app.save()">‚úÖ OK</button>
        </div>
    </div>

    <div id="view-result">
        <img id="final-img">
        <button class="btn-rot" onclick="app.reset()" style="padding:15px; margin-top:20px;">üì∏ Nueva Foto</button>
    </div>

    <script src="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.js"></script>
    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="app.onOpenCVReady()"></script>

    <script>
        // Objeto principal para encapsular la l√≥gica y evitar errores globales
        const app = {
            video: document.getElementById('video'),
            canvas: document.getElementById('canvas-out'),
            ctx: null,
            logEl: document.getElementById('status-log'),
            
            // Estado
            stream: null,
            isScanning: false,
            cropper: null,
            detectedRect: null,
            
            // Matrices OpenCV
            mat: { src: null, gray: null, binary: null, contours: null, hierarchy: null },

            log: function(msg) {
                this.logEl.innerText = msg;
                console.log(msg);
            },

            onOpenCVReady: function() {
                this.log("‚úÖ OpenCV Cargado. Iniciando c√°mara...");
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.startCamera();
            },

            startCamera: async function() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
                    });
                    this.stream = stream;
                    this.video.srcObject = stream;
                    await this.video.play();
                    
                    // Ajustar canvas al tama√±o real
                    this.canvas.width = this.video.videoWidth;
                    this.canvas.height = this.video.videoHeight;
                    
                    this.initMats();
                    this.isScanning = true;
                    this.process();
                } catch (e) {
                    this.log("‚ùå Error C√°mara: " + e.message + "\nPrueba en Safari (iOS) o Chrome (Android) y da permisos.");
                }
            },

            initMats: function() {
                try {
                    this.mat.src = new cv.Mat(this.canvas.height, this.canvas.width, cv.CV_8UC4);
                    this.mat.gray = new cv.Mat();
                    this.mat.binary = new cv.Mat();
                    this.mat.contours = new cv.MatVector();
                    this.mat.hierarchy = new cv.Mat();
                } catch(e) { this.log("Error Memoria OpenCV: " + e); }
            },

            process: function() {
                if (!this.isScanning) return;
                
                try {
                    // 1. Dibujar video
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    let imgData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    this.mat.src.data.set(imgData.data);

                    // 2. Procesar
                    cv.cvtColor(this.mat.src, this.mat.gray, cv.COLOR_RGBA2GRAY);
                    // Blur y Threshold
                    cv.GaussianBlur(this.mat.gray, this.mat.gray, new cv.Size(9, 9), 0);
                    cv.threshold(this.mat.gray, this.mat.binary, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
                    
                    // 3. Contornos
                    cv.findContours(this.mat.binary, this.mat.contours, this.mat.hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    let maxArea = 0;
                    let bestIndex = -1;

                    for (let i = 0; i < this.mat.contours.size(); ++i) {
                        let cnt = this.mat.contours.get(i);
                        let area = cv.contourArea(cnt);
                        if (area > 30000) {
                            if (area > maxArea) {
                                maxArea = area;
                                bestIndex = i;
                            }
                        }
                    }

                    this.detectedRect = null;
                    if (bestIndex !== -1) {
                        let cnt = this.mat.contours.get(bestIndex);
                        let rect = cv.minAreaRect(cnt);
                        this.detectedRect = rect;
                        
                        // Dibujar caja amarilla
                        this.drawRotatedRect(rect);
                        this.log("‚úÖ TICKET DETECTADO\nPulsa el bot√≥n blanco");
                    } else {
                        this.log("üîç Buscando ticket...\nPon fondo oscuro");
                    }

                } catch (e) {
                   // Ignoramos errores puntuales de frame
                }
                
                requestAnimationFrame(() => this.process());
            },

            drawRotatedRect: function(rect) {
                let vertices = cv.RotatedRect.points(rect);
                this.ctx.beginPath();
                this.ctx.lineWidth = 6;
                this.ctx.strokeStyle = "yellow";
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < 4; i++) this.ctx.lineTo(vertices[i].x, vertices[i].y);
                this.ctx.closePath();
                this.ctx.stroke();
            },

            // --- FASE DE CAPTURA ---
           // --- FASE DE CAPTURA CORREGIDA ---
            capture: function() {
                this.isScanning = false;
                this.log("üì∏ Procesando imagen...");

                let srcMat = new cv.Mat(this.canvas.height, this.canvas.width, cv.CV_8UC4);
                let finalMat = new cv.Mat();
                let cropped = new cv.Mat();

                try {
                    // 1. Leemos imagen LIMPIA del video
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    let imgData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    srcMat.data.set(imgData.data);

                    if (this.detectedRect) {
                        // --- L√ìGICA DE ROTACI√ìN Y RECORTE ---
                        
                        let center = this.detectedRect.center;
                        let size = this.detectedRect.size;
                        let angle = this.detectedRect.angle;

                        // Ajustar √°ngulo para que el ticket quede vertical
                        if (angle < -45) {
                            angle += 90;
                            let tmp = size.width; size.width = size.height; size.height = tmp;
                        }
                        
                        // A√±adir un peque√±o margen (10%) para no cortar bordes del ticket
                        size.width = size.width * 1.1;
                        size.height = size.height * 1.1;

                        // A. Crear Matriz de Rotaci√≥n
                        let M = cv.getRotationMatrix2D(center, angle, 1);
                        
                        // B. Rotar la imagen completa (WarpAffine sustituye a getRectSubPix)
                        cv.warpAffine(srcMat, finalMat, M, srcMat.size(), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(0,0,0,255));
                        
                        // C. Calcular coordenadas para recortar el centro (ROI)
                        let x = Math.round(center.x - (size.width / 2));
                        let y = Math.round(center.y - (size.height / 2));
                        let w = Math.round(size.width);
                        let h = Math.round(size.height);

                        // D. Comprobaciones de seguridad (Para que no crashee si se sale del borde)
                        if (x < 0) x = 0;
                        if (y < 0) y = 0;
                        if (x + w > finalMat.cols) w = finalMat.cols - x;
                        if (y + h > finalMat.rows) h = finalMat.rows - y;

                        // E. Recortar
                        let rect = new cv.Rect(x, y, w, h);
                        cropped = finalMat.roi(rect);
                        
                        // Mostrar en el canvas temporal para convertir a imagen
                        cv.imshow('canvas-out', cropped);
                        
                        // Limpieza
                        M.delete();
                    } else {
                        // Si no se detect√≥ nada, pasamos la foto entera
                        this.log("‚ö†Ô∏è No detectado, pasando foto completa");
                        cv.imshow('canvas-out', srcMat);
                    }

                    // Convertir resultado a URL para el editor
                    let dataUrl = this.canvas.toDataURL('image/jpeg');
                    
                    // Abrir editor
                    this.openEditor(dataUrl);

                } catch (e) {
                    this.log("‚ùå Error al procesar: " + e.message);
                    console.error(e);
                } finally {
                    // Limpieza de memoria obligatoria
                    if(srcMat) srcMat.delete();
                    if(finalMat) finalMat.delete();
                    if(cropped) cropped.delete();
                }
            },

            openEditor: function(url) {
                document.getElementById('view-camera').style.display = 'none';
                document.getElementById('view-editor').style.display = 'flex';
                this.log("üñåÔ∏è Abriendo editor...");

                let img = document.getElementById('image-to-edit');
                img.src = url;
                img.style.display = 'block';

                // TRUCO VITAL: Esperar a que el navegador pinte el div antes de cargar Cropper
                // Si esto falla, el editor sale negro o bloqueado.
                setTimeout(() => {
                    if (this.cropper) this.cropper.destroy();
                    this.cropper = new Cropper(img, {
                        viewMode: 1,
                        dragMode: 'move',
                        autoCropArea: 0.9,
                        background: false,
                        movable: true,
                        zoomable: true,
                        ready: () => {
                            this.log("‚úÖ Editor listo. Ajusta y guarda.");
                        }
                    });
                }, 200); // 200ms de retraso
            },

            rotate: function(deg) {
                if (this.cropper) this.cropper.rotate(deg);
            },

            save: function() {
                if (!this.cropper) return;
                let resultCanvas = this.cropper.getCroppedCanvas({
                    maxWidth: 2048, maxHeight: 2048
                });
                
                document.getElementById('view-editor').style.display = 'none';
                document.getElementById('view-result').style.display = 'flex';
                document.getElementById('final-img').src = resultCanvas.toDataURL('image/jpeg');
                this.log("‚ú® ¬°Escaneo completado!");
            },

            reset: function() {
                if (this.cropper) { this.cropper.destroy(); this.cropper = null; }
                document.getElementById('image-to-edit').src = "";
                
                document.getElementById('view-result').style.display = 'none';
                document.getElementById('view-editor').style.display = 'none';
                document.getElementById('view-camera').style.display = 'flex';
                
                this.isScanning = true;
                this.log("üì∑ C√°mara reiniciada");
                this.process();
            }
        };

        // Event Listeners
        document.getElementById('btn-capture').onclick = () => app.capture();

    </script>
</body>
</html>

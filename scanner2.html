<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner: Correcci√≥n de Perspectiva</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { width: 100%; height: 100%; object-fit: contain; }
        
        #ui-layer { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; }
        #btnSnap {
            pointer-events: auto;
            background: #2196F3; color: white; border: 4px solid white;
            width: 80px; height: 80px; border-radius: 50%;
            font-size: 0; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            display: inline-block;
        }
        
        #log { 
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #0f0; text-shadow: 1px 1px 0 #000; font-weight: bold; font-size: 14px; z-index: 10;
        }

        /* Pantalla de Resultado */
        #resultScreen {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #111; z-index: 100; flex-direction: column; align-items: center; justify-content: center;
        }
        #resultCanvas {
            max-width: 95%; max-height: 85%; border: 2px solid #fff; margin-bottom: 20px;
        }
        #btnBack {
            padding: 15px 40px; background: #444; color: white; border: none;
            border-radius: 8px; font-size: 16px; cursor: pointer;
        }

        video { display: none; }
    </style>
</head>
<body>

    <div id="container">
        <div id="log">Cargando l√≥gica de escaneo...</div>
        <video id="video" playsinline muted></video>
        <canvas id="canvasOut"></canvas>
        <div id="ui-layer">
            <button id="btnSnap">ESCANEAR</button>
        </div>
    </div>

    <div id="resultScreen">
        <canvas id="resultCanvas"></canvas>
        <button id="btnBack">‚ùå Cerrar y Repetir</button>
    </div>

    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady();"></script>

    <script>
        const log = (t) => document.getElementById('log').innerText = t;
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvasOut');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Elementos Resultado
        const resScreen = document.getElementById('resultScreen');
        const resCanvas = document.getElementById('resultCanvas');
        const btnSnap = document.getElementById('btnSnap');
        const btnBack = document.getElementById('btnBack');

        let src, gray, binary, contours, hierarchy, hull;
        let detectedContour = null; // Guardar√° los 4 puntos detectados
        let isStreaming = false;

        function onOpenCvReady() {
            log("üì∑ Iniciando c√°mara...");
            startCamera();
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
                });
                video.srcObject = stream;
                await video.play();

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                initOpenCV();
                requestAnimationFrame(processVideo);
            } catch (err) {
                log("Error: " + err.message);
            }
        }

        function initOpenCV() {
            src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            gray = new cv.Mat();
            binary = new cv.Mat();
            contours = new cv.MatVector();
            hierarchy = new cv.Mat();
            isStreaming = true;
        }

        function processVideo() {
            if (!isStreaming) return;

            try {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                src.data.set(imgData.data);

                // 1. Pre-procesamiento para tickets dif√≠ciles
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
                cv.Canny(gray, binary, 75, 200); // Usamos Canny para bordes fuertes

                // Dilatamos para unir l√≠neas discontinuas del ticket arrugado
                let M = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.dilate(binary, binary, M, new cv.Point(-1, -1), 2);
                M.delete();

                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let bestContour = null;

                // 2. Buscar el contorno m√°s grande
                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > 50000) { // Filtro de tama√±o
                        if (area > maxArea) {
                            maxArea = area;
                            bestContour = cnt;
                        }
                    }
                }

                detectedContour = null;

                if (bestContour) {
                    // 3. Truco para arrugas: Usar Convex Hull y aproximar a 4 puntos
                    let hull = new cv.Mat();
                    cv.convexHull(bestContour, hull, false, true);
                    
                    let peri = cv.arcLength(hull, true);
                    let approx = new cv.Mat();
                    
                    // Intentamos aproximar el Hull a un cuadril√°tero (4 puntos)
                    // Jugamos con la precisi√≥n (epsilon) hasta encontrar 4 esquinas
                    cv.approxPolyDP(hull, approx, 0.02 * peri, true);
                    
                    // Si tiene 4 esquinas, es perfecto. Si tiene m√°s, es que est√° muy arrugado.
                    // Si tiene 4, lo guardamos.
                    if (approx.rows === 4) {
                        detectedContour = approx.clone(); // Guardamos para la captura
                        
                        // Dibujar contorno VERDE para indicar √©xito
                        drawPoly(src, approx, [0, 255, 0, 255]);
                        log("‚úÖ LISTO PARA ESCANEAR");
                    } else {
                         // Si no encuentra 4 esquinas exactas, dibujamos el Hull en amarillo
                         // (Significa: "Te veo, pero ac√©rcate o aplana un poco")
                         let tmpVec = new cv.MatVector();
                         tmpVec.push_back(hull);
                         cv.drawContours(src, tmpVec, 0, [255, 255, 0, 255], 2);
                         tmpVec.delete();
                         log("‚ö†Ô∏è Intenta aplanar el ticket");
                    }
                    
                    hull.delete();
                    approx.delete();
                } else {
                    log("üîç Buscando bordes...");
                }

                cv.imshow('canvasOut', src);

            } catch (e) { console.error(e); }
            requestAnimationFrame(processVideo);
        }

        // Funci√≥n auxiliar para dibujar pol√≠gonos
        function drawPoly(img, poly, color) {
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = `rgba(${color[0]},${color[1]},${color[2]},1)`;
            let pts = poly.data32S;
            ctx.moveTo(pts[0], pts[1]);
            for(let i=2; i < pts.length; i+=2) ctx.lineTo(pts[i], pts[i+1]);
            ctx.closePath();
            ctx.stroke();
        }

        // --- L√ìGICA DE TRANSFORMACI√ìN DE PERSPECTIVA ---
        btnSnap.onclick = () => {
            if (!detectedContour) {
                alert("Espera a que el borde se ponga VERDE");
                return;
            }
            isStreaming = false;

            // 1. Obtener las coordenadas de las esquinas detectadas
            let coords = [];
            for (let i = 0; i < 4; i++) {
                coords.push({ x: detectedContour.data32S[i * 2], y: detectedContour.data32S[i * 2 + 1] });
            }

            // 2. Ordenar esquinas: Top-Left, Top-Right, Bottom-Right, Bottom-Left
            // Esto es crucial para que el ticket no salga girado
            coords.sort((a,b) => a.y - b.y); // Ordenar por Y
            // Primeros 2 son top, ultimos 2 son bottom
            let tl = coords[0].x < coords[1].x ? coords[0] : coords[1];
            let tr = coords[0].x < coords[1].x ? coords[1] : coords[0];
            let bl = coords[2].x < coords[3].x ? coords[2] : coords[3];
            let br = coords[2].x < coords[3].x ? coords[3] : coords[2];

            // 3. Preparar matrices para WarpPerspective
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
            
            // Definir tama√±o de salida (puedes ajustar esto o calcularlo din√°micamente)
            let w = Math.max(Math.hypot(br.x-bl.x, br.y-bl.y), Math.hypot(tr.x-tl.x, tr.y-tl.y));
            let h = Math.max(Math.hypot(tr.x-br.x, tr.y-br.y), Math.hypot(tl.x-bl.x, tl.y-bl.y));
            
            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, w, 0, w, h, 0, h]);
            
            // 4. Aplicar Transformaci√≥n
            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            let finalDst = new cv.Mat();
            
            // Aqu√≠ ocurre la magia: "Planchar" la imagen
            // Usamos la imagen ORIGINAL (sin dibujar lineas verdes encima), 
            // por eso tendr√≠amos que haber guardado una copia limpia antes o...
            // simplemente limpiamos el video para la foto.
            // Para simplificar, usaremos 'src' (tendr√° las lineas verdes si no lo limpiamos).
            // TRUCO: Volvemos a leer del video para tener una imagen limpia
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            let cleanImgData = ctx.getImageData(0,0, canvas.width, canvas.height);
            let cleanMat = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            cleanMat.data.set(cleanImgData.data);

            cv.warpPerspective(cleanMat, finalDst, M, new cv.Size(w, h), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

            // 5. Mostrar resultado
            cv.imshow('resultCanvas', finalDst);
            resScreen.style.display = 'flex';

            // Limpieza de memoria
            srcTri.delete(); dstTri.delete(); M.delete(); finalDst.delete(); cleanMat.delete();
        };

        btnBack.onclick = () => {
            resScreen.style.display = 'none';
            isStreaming = true;
            requestAnimationFrame(processVideo);
        };
    </script>
</body>
</html>

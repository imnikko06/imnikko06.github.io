<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner Pro con Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; touch-action: none; }
        
        /* --- VISTA DE C√ÅMARA --- */
        #camContainer { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; background: black; }
        /* Usamos object-fit: cover para que la c√°mara ocupe toda la pantalla sin bordes negros */
        #canvasOut { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; }
        
        #ui-layer { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 10; pointer-events: none; }
        #btnSnap {
            pointer-events: auto;
            background: #ffcc00; color: black; border: 4px solid white;
            width: 80px; height: 80px; border-radius: 50%;
            font-weight: bold; font-size: 14px; box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
            cursor: pointer;
        }
        #btnSnap:active { transform: scale(0.95); }
        
        #log { 
            position: absolute; top: 50px; width: 100%; text-align: center;
            color: #ffcc00; text-shadow: 1px 1px 2px #000; font-weight: bold; font-size: 16px; z-index: 10;
            pointer-events: none;
        }

        /* --- VISTA DE EDITOR --- */
        #editorScreen {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #222; z-index: 100; flex-direction: column;
        }
        /* Contenedor para la imagen a editar, limitamos altura para dejar sitio a botones */
        .editor-canvas-container {
            flex: 1; width: 100%; overflow: hidden; background: #333; position: relative;
        }
        /* La imagen real dentro del editor */
        #editorImage { max-width: 100%; }

        /* Barra de herramientas inferior */
        .toolbar {
            height: 70px; background: #111; display: flex; justify-content: space-around; align-items: center; padding: 0 10px;
        }
        .toolbar button {
            padding: 10px 20px; border: none; border-radius: 8px; font-size: 18px; color: white; cursor: pointer;
        }
        .btn-rotate { background: #444; }
        .btn-save { background: #2196F3; font-weight: bold; padding: 10px 30px; }
        .btn-cancel { background: #d32f2f; }

        video { display: none; }
    </style>
</head>
<body>

    <div id="camContainer">
        <div id="log">Iniciando sistema...</div>
        <video id="video" playsinline muted></video>
        <canvas id="canvasOut"></canvas>
        <div id="ui-layer">
            <button id="btnSnap">CAPTURA</button>
        </div>
    </div>

    <div id="editorScreen">
        <div class="editor-canvas-container">
             <img id="editorImage" src="">
        </div>
        <div class="toolbar">
            <button class="btn-cancel" id="btnDiscard">‚ùå</button>
            <button class="btn-rotate" id="btnRotL">üîÑ Izq</button>
            <button class="btn-rotate" id="btnRotR">üîÑ Der</button>
            <button class="btn-save" id="btnSave">‚úÖ Guardar</button>
        </div>
    </div>

    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady();"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

    <script>
        // Referencias UI
        const log = (t) => document.getElementById('log').innerText = t;
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvasOut');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const camContainer = document.getElementById('camContainer');
        const btnSnap = document.getElementById('btnSnap');

        // Referencias Editor
        const editorScreen = document.getElementById('editorScreen');
        const editorImage = document.getElementById('editorImage');
        const btnRotL = document.getElementById('btnRotL');
        const btnRotR = document.getElementById('btnRotR');
        const btnSave = document.getElementById('btnSave');
        const btnDiscard = document.getElementById('btnDiscard');

        // Variables Globales
        let src, gray, binary, contours, hierarchy, detectedRotatedRect;
        let isStreaming = false;
        let cropper = null; // Instancia del editor

        function onOpenCvReady() {
            log("üì∑ Iniciando c√°mara...");
            startCamera();
        }

        async function startCamera() {
            try {
                // Preferencia por resoluci√≥n HD para mejor detalle
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
                });
                video.srcObject = stream;
                await video.play();

                // Ajustar canvas al tama√±o real del video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                initOpenCV();
                requestAnimationFrame(processVideo);
            } catch (err) {
                log("Error: " + err.message);
                alert("Error al acceder a la c√°mara. Aseg√∫rate de dar permisos.");
            }
        }

        function initOpenCV() {
            src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            gray = new cv.Mat();
            binary = new cv.Mat();
            contours = new cv.MatVector();
            hierarchy = new cv.Mat();
            isStreaming = true;
        }

        // --- BUCLE PRINCIPAL DE DETECCI√ìN ---
        function processVideo() {
            if (!isStreaming) return;

            try {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                src.data.set(imgData.data);

                // 1. Pre-procesamiento (Modo Bloque S√≥lido)
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, gray, new cv.Size(9, 9), 0); // Blur medio
                // Threshold OTSU + Binario Invertido suele funcionar mejor para papel blanco
                cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);

                // Dilataci√≥n agresiva para unir ticket arrugado
                let M = cv.Mat.ones(7, 7, cv.CV_8U);
                cv.dilate(binary, binary, M, new cv.Point(-1, -1), 2);
                M.delete();

                // 2. Buscar Contornos
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let bestCnt = null;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    // Filtro de tama√±o (ajustar si es necesario seg√∫n resoluci√≥n)
                    if (area > 30000) { 
                        if (area > maxArea) {
                            maxArea = area;
                            bestCnt = cnt;
                        }
                    }
                }

                detectedRotatedRect = null;

                if (bestCnt) {
                    // Usamos minAreaRect para envolver el bloque
                    let rotatedRect = cv.minAreaRect(bestCnt);
                    detectedRotatedRect = rotatedRect;

                    // Dibujar feedback visual
                    drawRotatedRect(ctx, rotatedRect);
                    log("‚úÖ TICKET DETECTADO");
                } else {
                    log("üîç Necesito contraste (Fondo oscuro)");
                }

            } catch (e) { console.error(e); }
            requestAnimationFrame(processVideo);
        }

        // Funci√≥n auxiliar para dibujar el rect√°ngulo rotado en el canvas JS
        function drawRotatedRect(ctx, rect) {
            let vertices = cv.RotatedRect.points(rect);
            ctx.beginPath();
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#FFCC00"; // Amarillo
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < 4; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            // Relleno sutil
            ctx.fillStyle = "rgba(255, 204, 0, 0.15)";
            ctx.fill();
        }

        // --- L√ìGICA DE CAPTURA Y PASE AL EDITOR ---
        btnSnap.onclick = () => {
            if (!detectedRotatedRect) {
                alert("No se ha detectado ning√∫n ticket.");
                return;
            }
            isStreaming = false; // Pausar c√°mara

            // 1. Realizar el recorte y enderezado autom√°tico inicial con OpenCV
            // (Esto es igual que el c√≥digo anterior)
            let center = detectedRotatedRect.center;
            let size = detectedRotatedRect.size;
            let angle = detectedRotatedRect.angle;
            if (angle < -45) { angle += 90; let temp = size.width; size.width = size.height; size.height = temp; }

            let rotMat = cv.getRotationMatrix2D(center, angle, 1);
            let warped = new cv.Mat();
            
            // Captura limpia desde el video
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            let cleanData = ctx.getImageData(0,0,canvas.width, canvas.height);
            let cleanSrc = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            cleanSrc.data.set(cleanData.data);

            // Rotar y recortar
            cv.warpAffine(cleanSrc, warped, rotMat, new cv.Size(canvas.width, canvas.height), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(0,0,0,255));
            let finalCrop = new cv.Mat();
            cv.getRectSubPix(warped, size, center, finalCrop);

            // 2. Convertir el resultado de OpenCV a una imagen para el editor
            // Usamos un canvas temporal invisible para esto
            let tempCanvas = document.createElement('canvas');
            cv.imshow(tempCanvas, finalCrop);
            let dataUrl = tempCanvas.toDataURL('image/jpeg');

            // 3. Cargar el editor
            openEditor(dataUrl);

            // Limpieza de memoria OpenCV
            rotMat.delete(); warped.delete(); finalCrop.delete(); cleanSrc.delete();
        };

        // --- FUNCIONES DEL EDITOR ---
        function openEditor(imageUrl) {
            camContainer.style.display = 'none'; // Ocultar c√°mara
            editorScreen.style.display = 'flex'; // Mostrar editor
            editorImage.src = imageUrl;

            // Destruir instancia previa si existe
            if (cropper) cropper.destroy();

            // Esperar a que la imagen cargue para iniciar Cropper
            editorImage.onload = () => {
                 cropper = new Cropper(editorImage, {
                    viewMode: 1, // Restringir el cuadro de recorte dentro del canvas
                    dragMode: 'move', // Permitir mover la imagen
                    autoCropArea: 0.95, // Empezar seleccionando casi todo
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                });
            };
        }

        // Botones de rotaci√≥n
        btnRotL.onclick = () => cropper.rotate(-90);
        btnRotR.onclick = () => cropper.rotate(90);

        // Bot√≥n Guardar (Terminar edici√≥n)
        btnSave.onclick = () => {
            // Obtener el resultado final del editor en alta resoluci√≥n
            let finalCanvas = cropper.getCroppedCanvas({
                maxWidth: 2048,
                maxHeight: 2048,
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high',
            });

            // Por ahora, simplemente reemplazamos la imagen del editor con el resultado final limpio
            // Aqu√≠ podr√≠as enviarlo a un servidor o permitir descarga.
            cropper.destroy(); // Quitamos la interfaz de edici√≥n
            editorImage.src = finalCanvas.toDataURL('image/jpeg', 0.9); // Mostramos el resultado jpg
            
            // Ocultamos botones de edici√≥n, dejamos solo el de salir
            document.querySelector('.toolbar').style.display = 'none';
            // Creamos un bot√≥n de "Nuevo Escaneo" temporalmente
            let newScanBtn = document.createElement('button');
            newScanBtn.innerText = "üîÑ Nuevo Escaneo";
            newScanBtn.style.cssText = "position:absolute; bottom:20px; left:50%; transform:translateX(-50%); padding:15px 30px; background:#2196F3; color:white; border:none; border-radius:30px; font-size:18px;";
            editorScreen.appendChild(newScanBtn);
            
            newScanBtn.onclick = () => {
                newScanBtn.remove();
                closeEditor();
            };
        };

        // Bot√≥n Descartar (Volver a c√°mara)
        btnDiscard.onclick = closeEditor;

        function closeEditor() {
            if (cropper) cropper.destroy();
            editorScreen.style.display = 'none';
            camContainer.style.display = 'flex';
            document.querySelector('.toolbar').style.display = 'flex'; // Restaurar toolbar
            editorImage.src = "";
            isStreaming = true;
            requestAnimationFrame(processVideo);
        }

    </script>
</body>
</html>

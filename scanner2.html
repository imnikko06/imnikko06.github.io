<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner Bloque S√≥lido</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; background: black; }
        canvas { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: contain; }
        
        #ui-layer { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 10; }
        #btnSnap {
            background: #ffcc00; color: black; border: 4px solid white;
            width: 80px; height: 80px; border-radius: 50%;
            font-weight: bold; font-size: 14px; box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
            cursor: pointer;
        }
        
        #log { 
            position: absolute; top: 50px; width: 100%; text-align: center;
            color: #ffcc00; text-shadow: 2px 2px 0 #000; font-weight: bold; font-size: 16px; z-index: 10;
            background: rgba(0,0,0,0.5); padding: 5px;
        }

        /* Pantalla Resultado */
        #resultScreen {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #111; z-index: 100; flex-direction: column; align-items: center; justify-content: center;
        }
        #resultCanvas {
            max-width: 90%; max-height: 80%; border: 2px solid #ffcc00; margin-bottom: 20px; object-fit: contain;
        }
        .btn-group { display: flex; gap: 20px; }
        button.secondary {
            padding: 15px 30px; background: #333; color: white; border: 1px solid #555;
            border-radius: 8px; font-size: 16px;
        }

        video { display: none; }
    </style>
</head>
<body>

    <div id="container">
        <div id="log">Cargando Sistema de Bloques...</div>
        <video id="video" playsinline muted></video>
        <canvas id="canvasOut"></canvas>
        <div id="ui-layer">
            <button id="btnSnap">CAPTURA</button>
        </div>
    </div>

    <div id="resultScreen">
        <canvas id="resultCanvas"></canvas>
        <div class="btn-group">
            <button class="secondary" id="btnBack">Intentar de nuevo</button>
        </div>
    </div>

    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady();"></script>

    <script>
        const log = (t) => document.getElementById('log').innerText = t;
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvasOut');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const resScreen = document.getElementById('resultScreen');
        const resCanvas = document.getElementById('resultCanvas');
        const btnSnap = document.getElementById('btnSnap');
        const btnBack = document.getElementById('btnBack');

        let src, gray, binary, contours, hierarchy;
        let detectedRotatedRect = null; // Guardar√° el rect√°ngulo rotado
        let isStreaming = false;

        function onOpenCvReady() {
            log("üì∑ Iniciando c√°mara...");
            startCamera();
        }

        async function startCamera() {
            try {
                // Pedimos resoluci√≥n media para que vaya r√°pido en m√≥viles
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                await video.play();

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                initOpenCV();
                requestAnimationFrame(processVideo);
            } catch (err) {
                log("Error: " + err.message);
            }
        }

        function initOpenCV() {
            src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            gray = new cv.Mat();
            binary = new cv.Mat();
            contours = new cv.MatVector();
            hierarchy = new cv.Mat();
            isStreaming = true;
        }

        function processVideo() {
            if (!isStreaming) return;

            try {
                // 1. Obtener imagen
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                src.data.set(imgData.data);

                // 2. Pre-procesamiento EXTREMO (Para ignorar arrugas)
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Blur muy fuerte para borrar letras y texturas
                cv.GaussianBlur(gray, gray, new cv.Size(11, 11), 0);
                
                // Threshold manual: Ajusta este 100 si necesitas m√°s sensibilidad
                // "Todo lo que sea m√°s brillante que 100 es ticket, lo dem√°s es fondo"
                // Usamos THRESH_OTSU para que calcule el brillo autom√°ticamente
                cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

                // Dilataci√≥n: "Engordar" el blanco para tapar agujeros negros (texto/arrugas)
                // Hacemos 3 pasadas de dilataci√≥n.
                let M = cv.Mat.ones(5, 5, cv.CV_8U);
                cv.dilate(binary, binary, M, new cv.Point(-1, -1), 3);
                M.delete();

                // 3. Buscar Contornos
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let bestCnt = null;

                // Buscar la mancha blanca m√°s grande
                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    // Solo consideramos manchas grandes (ticket)
                    if (area > 20000) { 
                        if (area > maxArea) {
                            maxArea = area;
                            bestCnt = cnt;
                        }
                    }
                }

                detectedRotatedRect = null;

                if (bestCnt) {
                    // --- LA CLAVE ---
                    // No buscamos esquinas. Buscamos el "minAreaRect".
                    // Esto devuelve el cuadro rotado que mejor encaja en la mancha.
                    let rotatedRect = cv.minAreaRect(bestCnt);
                    detectedRotatedRect = rotatedRect;

                    // Dibujar para el usuario
                    let vertices = cv.RotatedRect.points(rotatedRect);
                    
                    // Dibujamos las 4 l√≠neas del rect√°ngulo detectado
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = "#FFCC00"; // Amarillo
                        ctx.moveTo(vertices[i].x, vertices[i].y);
                        ctx.lineTo(vertices[(i + 1) % 4].x, vertices[(i + 1) % 4].y);
                        ctx.stroke();
                    }
                    
                    // Relleno semitransparente para confirmar detecci√≥n
                    ctx.fillStyle = "rgba(255, 204, 0, 0.2)";
                    ctx.fill();

                    log("‚úÖ TICKET DETECTADO");
                } else {
                    log("üîç Pon el ticket sobre fondo oscuro");
                }

                // No usamos imshow aqu√≠ para dibujar nosotros encima con el contexto JS (m√°s r√°pido para l√≠neas simples)
                // Pero necesitamos "limpiar" el canvas con el video original antes de pintar l√≠neas
                // (Ya lo hicimos con el ctx.drawImage al principio)

            } catch (e) { console.error(e); }
            requestAnimationFrame(processVideo);
        }

        // --- CAPTURA Y ROTACI√ìN ---
        btnSnap.onclick = () => {
            if (!detectedRotatedRect) {
                alert("No veo el ticket. Aseg√∫rate de tener fondo oscuro.");
                return;
            }
            isStreaming = false;

            // 1. Datos del rect√°ngulo rotado
            let center = detectedRotatedRect.center;
            let size = detectedRotatedRect.size;
            let angle = detectedRotatedRect.angle;

            // Ajuste de √°ngulo para OpenCV (a veces devuelve -90 a 0)
            if (angle < -45) {
                angle = angle + 90;
                // Intercambiar ancho y alto si giramos 90 grados
                let temp = size.width;
                size.width = size.height;
                size.height = temp;
            }

            // 2. Crear matriz de rotaci√≥n
            // Rotamos la imagen entera alrededor del centro del ticket para enderezarlo
            let M = cv.getRotationMatrix2D(center, angle, 1);
            let rotatedMat = new cv.Mat();
            
            // Leemos imagen limpia del video
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let cleanSrc = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            cleanSrc.data.set(imgData.data);

            // Rotar imagen
            cv.warpAffine(cleanSrc, rotatedMat, M, new cv.Size(canvas.width, canvas.height), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

            // 3. Recortar el rect√°ngulo (ahora que ya est√° derecho)
            let rectResult = new cv.Mat();
            // getRectSubPix extrae un rect√°ngulo con precisi√≥n de subp√≠xeles
            cv.getRectSubPix(rotatedMat, size, center, rectResult);

            // 4. Mostrar
            cv.imshow('resultCanvas', rectResult);
            resScreen.style.display = 'flex';

            // Limpieza
            M.delete(); rotatedMat.delete(); rectResult.delete(); cleanSrc.delete();
        };

        btnBack.onclick = () => {
            resScreen.style.display = 'none';
            isStreaming = true;
            requestAnimationFrame(processVideo);
        };
    </script>
</body>
</html>

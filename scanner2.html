<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner: Detector + Captura</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        
        /* Visor de CÃ¡mara */
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { width: 100%; height: 100%; object-fit: contain; }
        
        /* Botones y UI */
        #ui-layer { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; }
        #btnSnap {
            pointer-events: auto;
            background: #ff3b30; color: white; border: 4px solid white;
            width: 70px; height: 70px; border-radius: 50%;
            font-size: 0; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            display: inline-block;
        }
        #btnSnap:active { transform: scale(0.9); background: #cc2f26; }
        
        #log { 
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #0f0; text-shadow: 1px 1px 0 #000; font-weight: bold; font-size: 14px;
        }

        /* Pantalla de Resultado (Oculta al inicio) */
        #resultScreen {
            display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #1c1c1e; z-index: 100; flex-direction: column; align-items: center; justify-content: center;
        }
        #resultCanvas {
            max-width: 90%; max-height: 80%; border: 2px solid #fff; margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #btnBack {
            padding: 15px 40px; background: #333; color: white; border: 1px solid #555;
            border-radius: 8px; font-size: 16px; cursor: pointer;
        }

        video { display: none; }
    </style>
</head>
<body>

    <div id="container">
        <div id="log">Iniciando sistema...</div>
        <video id="video" playsinline muted></video>
        <canvas id="canvasOut"></canvas>
        
        <div id="ui-layer">
            <button id="btnSnap">CAPTURAR</button>
        </div>
    </div>

    <div id="resultScreen">
        <h2 style="color:white; margin-top:0;">Captura Detectada</h2>
        <canvas id="resultCanvas"></canvas>
        <button id="btnBack">ðŸ”„ Escanear otro</button>
    </div>

    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady();"></script>

    <script>
        const log = (t) => document.getElementById('log').innerText = t;
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvasOut');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Elementos de Resultado
        const resScreen = document.getElementById('resultScreen');
        const resCanvas = document.getElementById('resultCanvas');
        const btnSnap = document.getElementById('btnSnap');
        const btnBack = document.getElementById('btnBack');

        let src, gray, binary, contours, hierarchy, hull;
        let isStreaming = false;
        let currentRect = null; // AquÃ­ guardaremos las coordenadas del ticket detectado

        function onOpenCvReady() {
            log("CÃ¡mara iniciÃ¡ndose...");
            startCamera();
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                await video.play();

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                initOpenCV();
                requestAnimationFrame(processVideo);
            } catch (err) {
                log("Error: " + err.message);
            }
        }

        function initOpenCV() {
            src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
            gray = new cv.Mat();
            binary = new cv.Mat();
            contours = new cv.MatVector();
            hierarchy = new cv.Mat();
            hull = new cv.MatVector();
            isStreaming = true;
        }

        function processVideo() {
            if (!isStreaming) return;

            try {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                src.data.set(imgData.data);

                // --- PROCESAMIENTO ROBUSTO (Anti-Arrugas) ---
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Blur fuerte para eliminar letras
                cv.GaussianBlur(gray, gray, new cv.Size(9, 9), 0);
                
                // Threshold adaptativo (Mejor para sombras/arrugas)
                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

                // Dilatar para unir trozos rotos por arrugas
                let M = cv.Mat.ones(5, 5, cv.CV_8U);
                cv.dilate(binary, binary, M, new cv.Point(-1, -1), 2);
                M.delete();

                // Buscar contornos
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let maxIndex = -1;

                // Encontrar el objeto mÃ¡s grande
                for (let i = 0; i < contours.size(); ++i) {
                    let area = cv.contourArea(contours.get(i));
                    if (area > 30000) { // Filtro de tamaÃ±o mÃ­nimo
                        if (area > maxArea) {
                            maxArea = area;
                            maxIndex = i;
                        }
                    }
                }

                currentRect = null; // Reset

                if (maxIndex !== -1) {
                    let cnt = contours.get(maxIndex);
                    
                    // 1. Obtener Envoltorio Convexo (Ignora arrugas hacia adentro)
                    let tmpHull = new cv.Mat();
                    cv.convexHull(cnt, tmpHull, false, true);
                    
                    // 2. Obtener RectÃ¡ngulo delimitador (Bounding Box)
                    // Esto nos da x, y, ancho y alto para recortar despuÃ©s
                    let rect = cv.boundingRect(tmpHull);
                    currentRect = rect; // Guardamos para usarlo al capturar

                    // VisualizaciÃ³n:
                    // Dibujamos el contorno exacto en VERDE
                    let hullVec = new cv.MatVector();
                    hullVec.push_back(tmpHull);
                    cv.drawContours(src, hullVec, 0, [0, 255, 0, 255], 2);
                    
                    // Dibujamos el rectÃ¡ngulo de corte en ROJO (lo que se capturarÃ¡)
                    let pt1 = new cv.Point(rect.x, rect.y);
                    let pt2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                    cv.rectangle(src, pt1, pt2, [255, 0, 0, 255], 3);

                    log("âœ… Ticket detectado - Pulsa CAPTURAR");
                    
                    hullVec.delete(); 
                    tmpHull.delete();
                } else {
                    log("ðŸ” Buscando ticket...");
                }

                cv.imshow('canvasOut', src);

            } catch (e) {
                console.error(e);
            }
            requestAnimationFrame(processVideo);
        }

        // --- LÃ“GICA DE CAPTURA Y RECORTE ---
        btnSnap.onclick = () => {
            if (!currentRect) {
                alert("No se ha detectado ningÃºn ticket. Intenta acercarte o mejorar la luz.");
                return;
            }

            isStreaming = false; // Pausar video

            // 1. AÃ±adir margen de seguridad (Padding)
            // Para no cortar el ticket justo al borde si la detecciÃ³n fallÃ³ por 1mm
            let padding = 20; 
            let x = Math.max(currentRect.x - padding, 0);
            let y = Math.max(currentRect.y - padding, 0);
            let w = Math.min(currentRect.width + (padding*2), src.cols - x);
            let h = Math.min(currentRect.height + (padding*2), src.rows - y);
            
            let rectWithPadding = new cv.Rect(x, y, w, h);

            // 2. Recortar (ROI - Region of Interest)
            let cropped = src.roi(rectWithPadding);

            // 3. Mostrar en el canvas de resultado
            cv.imshow('resultCanvas', cropped);
            
            // Limpieza
            cropped.delete();

            // 4. Cambiar UI
            resScreen.style.display = 'flex';
        };

        btnBack.onclick = () => {
            resScreen.style.display = 'none';
            isStreaming = true;
            requestAnimationFrame(processVideo);
        };

    </script>
</body>
</html>

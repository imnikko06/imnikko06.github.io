<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Scanner Fuerza Bruta - Debug</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; text-align: center; margin: 0; }
        canvas { width: 100%; max-width: 600px; border: 2px solid #333; margin-top: 10px; }
        .controls { padding: 20px; background: #222; }
        #log { font-size: 12px; color: #888; margin-top: 10px; }
    </style>
</head>
<body>

    <div class="controls">
        <h3>Modo: Contraste Extremo</h3>
        <div id="status">Cargando OpenCV...</div>
        <div id="log">Esperando inicialización...</div>
    </div>

    <canvas id="canvasOut"></canvas>
    <video id="video" style="display:none"></video>

    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()"></script>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvasOut');
        const status = document.getElementById('status');
        const log = document.getElementById('log');

        let src, gray, corners;
        let streaming = false;

        function onOpenCvReady() {
            status.innerText = "✅ OpenCV Cargado";
            iniciarCamara();
        }

        function iniciarCamara() {
            navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: 640, height: 480 } 
            })
            .then(stream => {
                video.srcObject = stream;
                video.play();
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    initMatrices();
                    streaming = true;
                    requestAnimationFrame(procesar);
                };
            })
            .catch(e => status.innerText = "Err: " + e);
        }

        function initMatrices() {
            src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            gray = new cv.Mat();
            corners = new cv.Mat();
        }

        function procesar() {
            if (!streaming) return;

            try {
                let cap = new cv.VideoCapture(video);
                cap.read(src);

                // 1. Convertir a Gris
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                // 2. FORZAR CONTRASTE (Ecualización)
                // Esto hace que lo que es casi igual se vuelva muy diferente
                cv.equalizeHist(gray, gray);

                // 3. BUSCAR PUNTOS (Shi-Tomasi) con sensibilidad extrema
                // 100 puntos, calidad 0.001, distancia 10px
                cv.goodFeaturesToTrack(gray, corners, 100, 0.001, 10);

                // 4. DIBUJAR TODO EN EL CANVAS DE SALIDA
                // Primero dibujamos la imagen de la cámara (en gris para ver el contraste)
                cv.imshow('canvasOut', gray);

                // Dibujamos círculos rojos directamente sobre el canvas con la API de JS
                const ctx = canvas.getContext('2d');
                let puntosDetectados = corners.rows;
                log.innerText = `Puntos detectados: ${puntosDetectados} | Resolución: ${video.videoWidth}x${video.videoHeight}`;

                ctx.fillStyle = "red";
                for (let i = 0; i < corners.rows; i++) {
                    let x = corners.data32F[i * 2];
                    let y = corners.data32F[i * 2 + 1];
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    // Dibujar una cruz amarilla pequeña
                    ctx.strokeStyle = "yellow";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

            } catch (err) {
                console.log("Error en el loop:", err);
            }

            requestAnimationFrame(procesar);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scanner de Tickets Pro</title>
<style>
  body { font-family: sans-serif; background: #f0f0f0; text-align: center; margin: 0; padding: 10px; }
  .wrapper {
    position: relative;
    width: 100%;
    max-width: 480px;
    margin: 0 auto;
    background: #000;
  }
  video {
    width: 100%;
    display: block;
  }
  canvas#overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
  }
  #result {
    margin-top: 10px;
    border: 1px solid #ccc;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    max-width: 100%;
  }
  .status {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 3;
  }
</style>
</head>
<body>

<h2>Scanner de Tickets (Optimizado)</h2>

<div class="wrapper">
  <video id="video" playsinline webkit-playsinline muted autoplay></video>
  <canvas id="overlay"></canvas>
  <div id="status" class="status">Cargando OpenCV...</div>
</div>

<h3>Resultado:</h3>
<canvas id="result"></canvas>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
<script>
const video = document.getElementById("video");
const overlay = document.getElementById("overlay");
const octx = overlay.getContext("2d");
const resultCanvas = document.getElementById("result");
const statusDiv = document.getElementById("status");

let streaming = false;
let videoCap = null;
let src = null, gray = null, edges = null, dst = null;
let contours = null, hierarchy = null, approx = null;

let stableFrames = 0;
const REQUIRED_STABLE_FRAMES = 10; 

function onOpenCvReady() {
  statusDiv.innerText = "OpenCV Listo. Iniciando cámara...";
  startCamera();
}

function startCamera() {
  navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } },
    audio: false
  }).then(stream => {
    video.srcObject = stream;
    video.play();
    video.onloadedmetadata = () => {
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
      streaming = true;
      initCV();
      requestAnimationFrame(processVideo);
    };
  }).catch(err => {
    statusDiv.innerText = "Error cámara: " + err;
  });
}

function initCV() {
  // Inicializar matrices una sola vez para evitar fugas de memoria
  src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
  gray = new cv.Mat();
  edges = new cv.Mat();
  dst = new cv.Mat();
  contours = new cv.MatVector();
  hierarchy = new cv.Mat();
  approx = new cv.Mat();
  
  // Usar VideoCapture es mucho más rápido que drawImage + getImageData
  videoCap = new cv.VideoCapture(video);
}

// Función CRÍTICA: Ordenar puntos (TL, TR, BR, BL)
function orderPoints(pts) {
  // pts es un array plano [x1, y1, x2, y2, ...]
  // Lo convertimos a array de objetos para facilitar
  let points = [
    { x: pts[0], y: pts[1] },
    { x: pts[2], y: pts[3] },
    { x: pts[4], y: pts[5] },
    { x: pts[6], y: pts[7] }
  ];

  // Ordenar por coordenada Y (Top vs Bottom)
  points.sort((a, b) => a.y - b.y);

  // Los dos primeros son top, los dos últimos bottom
  let top = points.slice(0, 2);
  let bottom = points.slice(2, 4);

  // En top, el de menor X es TL, mayor X es TR
  top.sort((a, b) => a.x - b.x);
  let tl = top[0];
  let tr = top[1];

  // En bottom, el de menor X es BL, mayor X es BR
  // Nota: Esto asume rectángulo simple. Para perspectiva extrema, se usa suma/resta.
  // Método robusto Suma/Diferencia:
  // TL: menor suma (x+y), BR: mayor suma
  // TR: mayor diferencia (x-y), BL: menor diferencia
  // Pero para tickets verticales, el sort simple suele bastar. Usemos el robusto abajo en 'capture'.
  
  bottom.sort((a, b) => a.x - b.x);
  let bl = bottom[0];
  let br = bottom[1];

  return [tl, tr, br, bl];
}

function checkBlur(mat) {
  let lap = new cv.Mat();
  cv.Laplacian(mat, lap, cv.CV_64F);
  let meanStdDev = new cv.Mat();
  let stdDev = new cv.Mat();
  // La desviación estándar de la Laplaciana es una mejor métrica de nitidez
  cv.meanStdDev(lap, meanStdDev, stdDev);
  let score = stdDev.data64F[0] *
